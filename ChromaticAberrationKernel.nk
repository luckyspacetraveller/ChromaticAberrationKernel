set cut_paste_input [stack 0]
version 10.5 v7
push $cut_paste_input
Group {
 name ChromaticAberrationKernel
 selected true
 xpos 601
 ypos -71
 addUserKnob {20 ChromaticAberrationKernel}
 addUserKnob {6 smear_chroma l "Smear Chroma" t "If enabled, the plugin will smear the channels instead of just offsetting them." +STARTLINE}
 smear_chroma true
 addUserKnob {6 true_chroma l "True Chroma Blur" t "If enabled, Red/Green/Blue Scale will act as offsets. In nature, red smears to green and green to blue.\n\nIf disabled, Red/Green/Blue Scale will act as absolute values." -STARTLINE}
 true_chroma true
 addUserKnob {26 text_2 l "" +STARTLINE T "  "}
 addUserKnob {12 center l Center}
 center {{width/2} {height/2}}
 addUserKnob {41 "Center Size" T "BlinkScript3.ChromaticAberrationKernel_Center Size"}
 addUserKnob {7 strength l "Chroma Scale" R 0 100}
 strength 1
 addUserKnob {7 rotation l "Chroma Rotation" R -250 250}
 addUserKnob {26 text l "" +STARTLINE T "   "}
 addUserKnob {14 redscale l "Red Scale" R 0 100}
 redscale 1
 addUserKnob {14 greenscale l "Green Scale" R 0 100}
 greenscale 1
 addUserKnob {14 bluescale l "Blue Scale" R 0 100}
 bluescale 1
 addUserKnob {26 text_3 l "" +STARTLINE T "   "}
 addUserKnob {20 hue l "Hue Shift" t "Hue Shift effected Pixels only" n 1}
 hue 0
 addUserKnob {41 "Red Balance" T "BlinkScript3.ChromaticAberrationKernel_Red Balance"}
 addUserKnob {41 "Green Balance" T "BlinkScript3.ChromaticAberrationKernel_Green Balance"}
 addUserKnob {41 "Blue Balance" T "BlinkScript3.ChromaticAberrationKernel_Blue Balance"}
 addUserKnob {20 endGroup n -1}
 addUserKnob {20 noise l Noise t "add Noise to pixel position offset" n 1}
 noise 0
 addUserKnob {7 noise_amplitude l Amplitude R 0 10}
 addUserKnob {41 Z T BlinkScript3.ChromaticAberrationKernel_Z}
 addUserKnob {13 noise_scale l Scale}
 noise_scale {0.002 0.002 0.002}
 addUserKnob {41 noiseOverDistance l "Noise over Distance" T BlinkScript3.ChromaticAberrationKernel_noiseOverDistance}
 addUserKnob {26 text_1 l "" +STARTLINE T "    "}
 addUserKnob {41 Octaves T BlinkScript3.ChromaticAberrationKernel_Octaves}
 addUserKnob {41 Gain T BlinkScript3.ChromaticAberrationKernel_Gain}
 addUserKnob {41 Lacunarity T BlinkScript3.ChromaticAberrationKernel_Lacunarity}
 addUserKnob {7 noise_gamma l Gamma R 0.2 2}
 noise_gamma 1
 addUserKnob {13 noise_offset l Offset}
 addUserKnob {20 endGroup_1 l endGroup n -1}
 addUserKnob {26 ""}
 addUserKnob {6 calc_alpha l "Render new Alpha" t "Enables color-weighted alpha rendering" +STARTLINE}
 calc_alpha true
 addUserKnob {7 chroma_mix l Mix}
 chroma_mix 1
 addUserKnob {26 ""}
 addUserKnob {41 "Local GPU: " T BlinkScript3.gpuName}
 addUserKnob {41 "Use GPU if Available" T BlinkScript3.useGPUIfAvailable}
 addUserKnob {20 credit l Credit}
 addUserKnob {26 chroma l "" +STARTLINE T "<b>ChromaAberrationKernel v1.0</b>"}
 addUserKnob {26 credits l "" +STARTLINE T "01/2019\n\nLukas Schwabe\nMackevision"}
}
 Input {
  inputs 0
  name Input
  xpos -4
  ypos 275
 }
 Shuffle {
  name Shuffle1
  label "\[value in]"
  xpos -4
  ypos 325
 }
 BlinkScript {
  kernelSourceFile //data/HAM-1406-00249-MVH/_LukeS/depth/ChromaticAberrationKernel_v05.cpp
  recompileCount 21
  ProgramGroup 1
  KernelDescription "2 \"ChromaticAberrationKernel\" iterate pixelWise 2e2d0d0ca4d989cde451d00456880488b1ffb9e926e867e4044f8c2787a29c09 2 \"src\" Read Ranged2D \"dst\" Write Point 24 \"Smear Chroma\" Bool 1 AQ== \"True Chroma Blur\" Bool 1 AQ== \"calcAlpha\" Bool 1 AA== \"Resolution\" Int 2 gAcAADgEAAA= \"Center\" Int 2 wAMAABwCAAA= \"Center Size\" Float 1 AACAPw== \"Chroma Mult\" Float 1 AAAgQQ== \"Chroma Red Mult\" Float 2 AACAPwAAgD8= \"Chroma Green Mult\" Float 2 AACAPwAAgD8= \"Chroma Blue Mult\" Float 2 AACAPwAAgD8= \"Chroma Rotation\" Float 1 AAAAAA== \"Chroma Mix\" Float 1 AACAPw== \"Red Balance\" Float 4 AACAPwAAAAAAAAAAAAAAAA== \"Green Balance\" Float 4 AAAAAAAAgD8AAAAAAAAAAA== \"Blue Balance\" Float 4 AAAAAAAAAAAAAIA/AAAAAA== \"Octaves\" Float 1 AAAgQQ== \"Gain\" Float 1 AAAAPw== \"Lacunarity\" Float 1 AAAAQA== \"Gamma\" Float 1 AAAAPw== \"Z\" Float 1 AABIQg== \"amplitude\" Float 1 AAAAPw== \"Offset\" Float 3 AAAAAAAAAAAAAAAAAAAAAA== \"Scale\" Float 3 bxKDOm8SgzpvEoM6AAAAAA== \"noiseOverDistance\" Float 1 AACAPw== 24 \"smear\" 1 1 \"trueChroma\" 1 1 \"calcAlpha\" 1 1 \"res\" 2 1 \"effectCenter\" 2 1 \"centerSize\" 1 1 \"chromaMult\" 1 1 \"chromaRed\" 2 1 \"chromaGreen\" 2 1 \"chromaBlue\" 2 1 \"chromaRotateMult\" 1 1 \"chromaMix\" 1 1 \"redChannel\" 4 1 \"greenChannel\" 4 1 \"blueChannel\" 4 1 \"octaves\" 1 1 \"gain\" 1 1 \"lacunarity\" 1 1 \"gamma\" 1 1 \"zz\" 1 1 \"amplitude\" 1 1 \"offset\" 3 1 \"scale\" 3 1 \"noiseOverDistance\" 1 1 13 \"srcrangeMin\" Int 2 1 AAAAAAAAAAA= \"srcrangeMax\" Int 2 1 AAAAAAAAAAA= \"_bokehOffset\" Int 2 1 AAAAAAAAAAA= \"center\" Float 2 1 AAAAAAAAAAA= \"res_max\" Int 1 1 AAAAAA== \"chromaMixClamped\" Float 1 1 AAAAAA== \"centerSizeClamped\" Float 1 1 AAAAAA== \"sChromaMult\" Float 1 1 AAAAAA== \"sChromaRotateMult\" Float 1 1 AAAAAA== \"gammaClamped\" Float 1 1 AAAAAA== \"m_width\" Int 1 1 AAAAAA== \"m_height\" Int 1 1 AAAAAA== \"noiseMult\" Float 1 1 AAAAAA=="
  kernelSource "// ChromaticAberrationKernel v1.0\n// by Lukas Schwabe - Mackevision - 01-2019\n// fbm_Noise_blink_kernel v1.0 by Johannes Saam - Nukepedia\n\n\nkernel ChromaticAberrationKernel : ImageComputationKernel<ePixelWise> \{\n\n    Image<eRead, eAccessRanged2D, eEdgeClamped> src;\n    Image<eWrite> dst;\n\n    param:\n    bool smear;\n    bool trueChroma;\n    bool calcAlpha;\n\n    // float kernelSize;\n    int2 res;\n    int2 effectCenter;\n\n    float centerSize;\n\n    float chromaMult;\n\n    float2 chromaRed;\n    float2 chromaGreen;\n    float2 chromaBlue;\n\n    float chromaRotateMult;\n\n    float chromaMix;\n\n    float4 redChannel;\n    float4 greenChannel;\n    float4 blueChannel;\n\n    // noise vals\n    float octaves;\n    float gain;\n    float lacunarity;\n    float gamma;\n    float zz;\n    float amplitude;\n    float3 offset;\n    float3 scale;\n\n    float noiseOverDistance;\n\n\n\n    local:\n    int2 _bokehOffset;\n    float2 center;\n    int res_max;\n\n    float chromaMixClamped;\n    float centerSizeClamped;\n    float sChromaMult;\n    float sChromaRotateMult;\n    float gammaClamped;\n\n\n    // noise vals\n    int m_width;\n    int m_height;\n\n    float noiseMult;\n\n\n    void define() \{\n\n        defineParam(smear, \"Smear Chroma\", true);\n        defineParam(trueChroma, \"True Chroma Blur\", true);\n\n        defineParam(res, \"Resolution\", int2(1920, 1080));\n        defineParam(effectCenter, \"Center\", int2(960, 540));\n\n        defineParam(centerSize, \"Center Size\", 1.0f);\n        defineParam(chromaMult, \"Chroma Mult\", 10.0f);\n\n        defineParam(chromaRed, \"Chroma Red Mult\", float2(1.0f,1.0f));\n        defineParam(chromaGreen, \"Chroma Green Mult\", float2(1.0f,1.0f));\n        defineParam(chromaBlue, \"Chroma Blue Mult\", float2(1.0f,1.0f));\n\n        defineParam(chromaRotateMult, \"Chroma Rotation\", 0.0f);\n\n        defineParam(chromaMix, \"Chroma Mix\", 1.0f);\n\n        defineParam(redChannel, \"Red Balance\", float4(1.0f,0.0f,0.0f,0.0f));\n        defineParam(greenChannel, \"Green Balance\", float4(0.0f,1.0f,0.0f,0.0f));\n        defineParam(blueChannel, \"Blue Balance\", float4(0.0f,0.0f,1.0f,0.0f));\n\n        // noise vals\n        defineParam(octaves, \"Octaves\", 10.0f);\n        defineParam(gain, \"Gain\", 0.5f);\n        defineParam(lacunarity, \"Lacunarity\", 2.0f);\n        defineParam(gamma, \"Gamma\", 0.5f);\n        defineParam(amplitude, \"amplitude\", 0.5f);\n        defineParam(zz, \"Z\", 50.0f);\n        defineParam(offset, \"Offset\", float3(0.0f, 0.0f, 0.0f));\n        defineParam(scale, \"Scale\", float3(0.001f, 0.001f, 0.001f));\n        defineParam(noiseOverDistance, \"noiseOverDistance\", 1.0f);\n    \}\n\n    void init() \{\n\n        // avoid user values that will crash\n        chromaMixClamped = clamp(chromaMix,0.0f,1.0f);\n        centerSizeClamped = centerSize<0.0f?0.0f:centerSize;\n        noiseMult = max(noiseOverDistance,0.0f);\n        gammaClamped = clamp(gammaClamped, 0.2f,2.0f);\n\n        // max size\n        res_max = max(res.x,res.y);\n\n        // bring chroma Mults to reasonable values\n        sChromaMult = chromaMult / 300;\n        sChromaRotateMult = -chromaRotateMult / 200;\n\n        src.setRange(-res_max, res_max);\n\n        // set center point\n        center.x = effectCenter.x;\n        center.y = effectCenter.y;\n\n        m_width = dst.bounds.width();\n        m_height = dst.bounds.height();\n\n    \}\n\n    // Chromatic Aberration Kernel\n    void process(int2 pos) \{\n\n        SampleType(src) chromaDst(0);\n        SampleType(src) chromaDstEffected(0);\n\n        float2 offset;\n        float2 direction;\n        float distanceToCenter;\n        float nDistanceToCenter;\n        float sDistanceToCenter;\n\n        float2 posRed;\n        float2 posGreen;\n        float2 posBlue;\n\n        offset.x = (float)pos.x-center.x;\n        offset.y = (float)pos.y-center.y;\n\n        if (offset.x == 0.0f && offset.y == 0.0f) \{\n            direction = 0.0f;\n            distanceToCenter = 0.0f;\n        \}\n        else \{\n            direction = normalize(offset);\n            distanceToCenter = length(offset);\n        \}\n\n        if (distanceToCenter >= 1.0f) \{\n            nDistanceToCenter = distanceToCenter/res_max;\n            sDistanceToCenter = pow(nDistanceToCenter,centerSizeClamped);\n        \}\n        else \{\n            nDistanceToCenter = 0.0f;\n            sDistanceToCenter = 0.0f;\n        \}\n\n\n        //generate sin and cos for rotation\n        float cs = cos(3.1415926535f/180.0f);\n        float sn = sin(3.1415926535f/180.0f);\n\n        // calc aberrated positions with scale and rotation and noise\n        float getThatNoise = getNoise(pos,sDistanceToCenter);\n        float2 noise;\n\n        noise.x = getThatNoise*-direction.x;\n        noise.y = getThatNoise*-direction.y;\n\n        posRed.x =-distanceToCenter * sDistanceToCenter * direction.x * sChromaMult * chromaRed.x + ((sn*offset.x + cs*offset.y) * sDistanceToCenter * sChromaRotateMult * chromaRed.x )+noise.x;\n        posRed.y =-distanceToCenter * sDistanceToCenter * direction.y * sChromaMult * chromaRed.y + ((-cs*offset.x + sn*offset.y) * sDistanceToCenter * sChromaRotateMult * chromaRed.y)+noise.y;\n\n        posGreen.x = -distanceToCenter * sDistanceToCenter * direction.x * sChromaMult * chromaGreen.x + ((sn*offset.x + cs*offset.y) * sDistanceToCenter * sChromaRotateMult * chromaGreen.x )+noise.x;\n        posGreen.y = -distanceToCenter * sDistanceToCenter * direction.y * sChromaMult * chromaGreen.y + ((-cs*offset.x + sn*offset.y) * sDistanceToCenter * sChromaRotateMult * chromaGreen.y)+noise.y;\n\n        posBlue.x = -distanceToCenter * sDistanceToCenter * direction.x * sChromaMult * chromaBlue.x + ((sn*offset.x + cs*offset.y) * sDistanceToCenter * sChromaRotateMult * chromaBlue.x )+noise.x;\n        posBlue.y = -distanceToCenter * sDistanceToCenter * direction.y * sChromaMult * chromaBlue.y + ((-cs*offset.x + sn*offset.y) * sDistanceToCenter * sChromaRotateMult * chromaBlue.y)+noise.y;\n\n        float lengthRed = length(posRed);\n        float lengthGreen = length(posGreen);\n        float lengthBlue = length(posBlue);\n\n        float filterStart = 0.0f;\n\n\n\n        if (smear == true) \{ //smear\n\n\n            float stretchRed = 0;\n            float stretchGreen = 0;\n            float stretchBlue = 0;\n            float stretchAlpha = 0;\n\n\n            if (trueChroma == true) \{ //true chroma mode\n\n                int counterRed = (int)fabs(lengthRed)+1;\n                int counterGreen = (int)fabs(lengthGreen)+1;\n                int counterBlue = (int)fabs(lengthBlue)+1;\n\n                //red\n                if (lengthRed > filterStart) \{\n\n                    int loopRuns = 0;\n                    stretchAlpha = 0;\n                    for (int count=0 ; count <= counterRed; count++) \{\n\n                        float stepValue = (float)count/(float)counterRed;\n\n                        stretchRed += bilinear(src, posRed.x*stepValue , posRed.y*stepValue, 0) * stepValue;\n                        if (stepValue != 1) \{\n                          stretchRed += bilinear(src, posRed.x*2-posRed.x*stepValue , posRed.y*2-posRed.y*stepValue, 0) * stepValue;\n                        \}\n\n                        if (calcAlpha == true) \{\n                            stretchAlpha += bilinear(src, posRed.x*stepValue , posRed.y*stepValue, 3) * stepValue;\n                            if (stepValue != 1) \{\n                              stretchAlpha += bilinear(src, posRed.x*2-posRed.x*stepValue , posRed.y*2-posRed.y*stepValue, 3) * stepValue;\n                            \}\n                        \}\n\n\n                        loopRuns +=1;\n                    \}\n\n\n                    chromaDstEffected.x += stretchRed / (loopRuns-1);\n                    if (calcAlpha == true) \{\n                        chromaDstEffected.w += (stretchAlpha / (loopRuns-1))*0.299f;\n                    \}\n                \}\n                else \{\n                    chromaDst.x += bilinear(src, posRed.x, posRed.y, 0);\n                    if (calcAlpha == true) \{\n                        chromaDst.w += bilinear(src, posRed.x, posRed.y, 3)*0.299f;\n                    \}\n                \}\n\n\n                //green\n                if (lengthGreen > filterStart) \{\n\n                    int loopRuns = 0;\n                    stretchAlpha = 0;\n                    for (int count=0 ; count <= counterGreen; count++) \{\n\n                        float stepValue = (float)count/(float)counterGreen;\n\n                        stretchGreen +=  bilinear(src, posGreen.x*stepValue+posRed.x, posGreen.y*stepValue+posRed.y, 1) * stepValue;\n                        if (stepValue != 1) \{\n                            stretchGreen += bilinear(src, posGreen.x*2-posGreen.x*stepValue+posRed.x , posGreen.y*2-posGreen.y*stepValue+posRed.y, 1) * stepValue;\n                        \}\n\n                        if (calcAlpha == true) \{\n                            stretchAlpha +=  bilinear(src, posGreen.x*stepValue+posRed.x, posGreen.y*stepValue+posRed.y, 3) * stepValue;\n                            if (stepValue != 1) \{\n                                stretchAlpha += bilinear(src, posGreen.x*2-posGreen.x*stepValue+posRed.x , posGreen.y*2-posGreen.y*stepValue+posRed.y, 3) * stepValue;\n                            \}\n                        \}\n\n                        loopRuns +=1;\n                    \}\n\n\n                    chromaDstEffected.y += stretchGreen / (loopRuns-1);\n                    if (calcAlpha == true) \{\n                        chromaDstEffected.w += (stretchAlpha / (loopRuns-1))*0.587f;\n                    \}\n                \}\n\n                else \{\n                    chromaDst.y += bilinear(src, posGreen.x, posGreen.y, 1);\n                    if (calcAlpha == true) \{\n                        chromaDst.w += bilinear(src, posGreen.x, posGreen.y, 3)*0.587f;\n                    \}\n\n                \}\n\n\n                //blue\n                if (lengthBlue > filterStart) \{\n\n                    int loopRuns = 0;\n                    stretchAlpha = 0;\n                    for (int count=0 ; count <= counterBlue; count++) \{\n\n                        float stepValue = (float)count/(float)counterBlue;\n\n                        stretchBlue += bilinear(src, posBlue.x*stepValue+posGreen.x+posRed.x , posBlue.y*stepValue+posGreen.y+posRed.y, 2) * stepValue ;\n                        if (stepValue != 1) \{\n                            stretchBlue += bilinear(src, posBlue.x*2-posBlue.x*stepValue+posGreen.x+posRed.x , posBlue.y*2-posBlue.y*stepValue+posGreen.y+posRed.y, 2) * stepValue;\n                        \}\n\n                        if (calcAlpha == true) \{\n                            stretchAlpha += bilinear(src, posBlue.x*stepValue+posGreen.x+posRed.x , posBlue.y*stepValue+posGreen.y+posRed.y, 3) * stepValue ;\n                            if (stepValue != 1) \{\n                                stretchAlpha += bilinear(src, posBlue.x*2-posBlue.x*stepValue+posGreen.x+posRed.x , posBlue.y*2-posBlue.y*stepValue+posGreen.y+posRed.y, 3) * stepValue;\n                            \}\n                        \}\n\n                        loopRuns +=1;\n\n                    \}\n\n\n                    chromaDstEffected.z += stretchBlue / (loopRuns-1);\n                    if (calcAlpha == true) \{\n                        chromaDstEffected.w += (stretchAlpha / (loopRuns-1))*0.114f;\n                    \}\n                \}\n\n                else \{\n                    chromaDst.z += bilinear(src, posBlue.x, posBlue.y, 2);\n                    if (calcAlpha == true) \{\n                        chromaDst.w += bilinear(src, posBlue.x, posBlue.y, 3)*0.114f;\n                    \}\n                \}\n\n            \} //true chroma mode end\n\n\n\n\n\n\n\n\n            else\{  // non true chroma mode\n                int counterRed = (int)fabs(lengthRed)+1;\n                int counterGreen = (int)fabs(lengthGreen)+1;\n                int counterBlue = (int)fabs(lengthBlue)+1;\n\n\n                //red\n                if (lengthRed > filterStart) \{\n\n                    int loopRuns = 0;\n                    stretchAlpha = 0;\n                    for (int count=0 ; count <= counterRed; count++) \{\n\n                        float stepValue = (float)count/(float)counterRed;\n\n\n                        stretchRed += bilinear(src, (posRed.x-noise.x*noiseMult)*stepValue+noise.x*noiseMult*stepValue*0.5f, (posRed.y-noise.y*noiseMult)*stepValue + noise.y*noiseMult*stepValue*0.5f, 0) * stepValue;\n                        if (stepValue != 1) \{\n\n                            stretchRed += bilinear(src, posRed.x*2-posRed.x*stepValue-noise.x*noiseMult*stepValue*0.5f, posRed.y*2-posRed.y*stepValue-noise.y*noiseMult*stepValue*0.5f, 0) * stepValue;\n                        \}\n\n                        if (calcAlpha == true) \{\n                            stretchAlpha += bilinear(src, (posRed.x-noise.x*noiseMult)*stepValue+noise.x*noiseMult*stepValue*0.5f, (posRed.y-noise.y*noiseMult)*stepValue + noise.y*noiseMult*stepValue*0.5f, 3) * stepValue;\n                            if (stepValue != 1) \{\n\n                                stretchAlpha += bilinear(src, posRed.x*2-posRed.x*stepValue-noise.x*noiseMult*stepValue*0.5f, posRed.y*2-posRed.y*stepValue-noise.y*noiseMult*stepValue*0.5f, 3) * stepValue;\n                            \}\n                        \}\n\n                        loopRuns +=1;\n                    \}\n\n\n                    chromaDstEffected.x += stretchRed / (loopRuns-1);\n                    if (calcAlpha == true) \{\n                        chromaDstEffected.w += (stretchAlpha / (loopRuns-1))*0.299f;\n                    \}\n                \}\n                else \{\n                    chromaDst.x += bilinear(src, posRed.x, posRed.y, 0);\n                    if (calcAlpha == true) \{\n                        chromaDst.w += bilinear(src, posRed.x, posRed.y, 3)*0.299f;\n                    \}\n                \}\n\n\n                //green\n                if (lengthGreen > filterStart) \{\n\n                    int loopRuns = 0;\n                    stretchAlpha = 0;\n                    for (int count=0 ; count <= counterGreen; count++) \{\n\n                        float stepValue = (float)count/(float)counterGreen;\n\n                        stretchGreen +=  bilinear(src, (posGreen.x-noise.x*noiseMult)*stepValue+noise.x*noiseMult*stepValue*0.5f, (posGreen.y-noise.y*noiseMult)*stepValue + noise.y*noiseMult*stepValue*0.5f, 1) * stepValue;\n                        if (stepValue != 1) \{\n                            stretchGreen += bilinear(src, posGreen.x*2-posGreen.x*stepValue-noise.x*noiseMult*stepValue*0.5f, posGreen.y*2-posGreen.y*stepValue-noise.y*noiseMult*stepValue*0.5f, 1) * stepValue;\n                        \}\n\n                        if (calcAlpha == true) \{\n                            stretchAlpha +=  bilinear(src, (posGreen.x-noise.x*noiseMult)*stepValue+noise.x*noiseMult*stepValue*0.5f, (posGreen.y-noise.y*noiseMult)*stepValue + noise.y*noiseMult*stepValue*0.5f, 3) * stepValue;\n                            if (stepValue != 1) \{\n                                stretchAlpha += bilinear(src, posGreen.x*2-posGreen.x*stepValue-noise.x*noiseMult*stepValue*0.5f, posGreen.y*2-posGreen.y*stepValue-noise.y*noiseMult*stepValue*0.5f, 3) * stepValue;\n                            \}\n                        \}\n                        loopRuns +=1;\n                    \}\n\n\n                    chromaDstEffected.y += stretchGreen / (loopRuns-1);\n                    if (calcAlpha == true) \{\n                        chromaDstEffected.w += (stretchAlpha / (loopRuns-1))*0.587f;\n                    \}\n                \}\n\n                else \{\n                    chromaDst.y += bilinear(src, posGreen.x, posGreen.y, 1);\n                    if (calcAlpha == true) \{\n                        chromaDst.w += bilinear(src, posGreen.x, posGreen.y, 3)*0.587f;\n                    \}\n\n                \}\n\n\n                //blue\n                if (lengthBlue > filterStart) \{\n\n                    int loopRuns = 0;\n                    stretchAlpha = 0;\n                    for (int count=0 ; count <= counterBlue; count++) \{\n\n                        float stepValue = (float)count/(float)counterBlue;\n\n                        stretchBlue += bilinear(src, (posBlue.x-noise.x*noiseMult)*stepValue+noise.x*noiseMult*stepValue*0.5f, (posBlue.y-noise.y*noiseMult)*stepValue + noise.y*noiseMult*stepValue*0.5f, 2) * stepValue;\n                        if (stepValue != 1) \{\n                            stretchBlue += bilinear(src, posBlue.x*2-posBlue.x*stepValue-noise.x*noiseMult*stepValue*0.5f, posBlue.y*2-posBlue.y*stepValue-noise.y*noiseMult*stepValue*0.5f, 2) * stepValue;\n                        \}\n\n                        if (calcAlpha == true) \{\n                            stretchAlpha += bilinear(src, (posBlue.x-noise.x*noiseMult)*stepValue+noise.x*noiseMult*stepValue*0.5f, (posBlue.y-noise.y*noiseMult)*stepValue + noise.y*noiseMult*stepValue*0.5f, 3) * stepValue;\n                            if (stepValue != 1) \{\n                                stretchAlpha += bilinear(src, posBlue.x*2-posBlue.x*stepValue-noise.x*noiseMult*stepValue*0.5f, posBlue.y*2-posBlue.y*stepValue-noise.y*noiseMult*stepValue*0.5f, 3) * stepValue;\n                            \}\n                        \}\n\n                        loopRuns +=1;\n                    \}\n\n\n                    chromaDstEffected.z += stretchBlue / (loopRuns-1);\n                    if (calcAlpha == true) \{\n                        chromaDstEffected.w += (stretchAlpha / (loopRuns-1))*0.114f;\n                    \}\n\n                \}\n\n                else \{\n                    chromaDst.z += bilinear(src, posBlue.x, posBlue.y, 2);\n                    if (calcAlpha == true) \{\n                        chromaDst.w += bilinear(src, posBlue.x, posBlue.y, 3)*0.114f;\n                    \}\n                \}\n\n\n\n            \} //non true chroma mode end\n\n        \} // end smear\n\n\n        else \{  //no smear\n\n            if (trueChroma == true) \{\n                posGreen += posRed;\n                posBlue += posGreen;\n            \}\n\n            if (lengthRed>filterStart) \{\n                chromaDstEffected.x += bilinear(src, posRed.x, posRed.y, 0);\n            \}\n            else \{\n                chromaDst.x = bilinear(src, posRed.x, posRed.y, 0);\n            \}\n\n\n            if (lengthGreen>filterStart) \{\n                chromaDstEffected.y += bilinear(src, posGreen.x, posGreen.y, 1);\n            \}\n            else \{\n                chromaDst.y = bilinear(src, posGreen.x, posGreen.y, 1);\n            \}\n\n\n            if (lengthBlue>filterStart) \{\n                chromaDstEffected.z += bilinear(src, posBlue.x, posBlue.y, 2);\n            \}\n            else \{\n                chromaDst.z= bilinear(src, posBlue.x, posBlue.y, 2);\n            \}\n\n            if (calcAlpha == true) \{\n                if (lengthRed>filterStart || lengthGreen>filterStart || lengthBlue>filterStart) \{\n                    chromaDstEffected.w = bilinear(src, posRed.x, posRed.y, 3)*0.299f + bilinear(src, posGreen.x, posGreen.y, 3)*0.587f + bilinear(src, posBlue.x, posBlue.y, 3)*0.114f;\n                \}\n            \}\n\n\n        \} // no smear end\n\n\n        // add up and hue shift effected pixels\n        chromaDst.x = chromaDst.x + chromaDstEffected.x*redChannel.x + chromaDstEffected.y*greenChannel.x*lengthGreen + chromaDstEffected.z*blueChannel.x*lengthBlue;\n        chromaDst.y = chromaDst.y + chromaDstEffected.x*redChannel.y*lengthRed + chromaDstEffected.y*greenChannel.y + chromaDstEffected.z*blueChannel.y*lengthBlue;\n        chromaDst.z = chromaDst.z + chromaDstEffected.x*redChannel.z*lengthRed + chromaDstEffected.y*greenChannel.z*lengthGreen + chromaDstEffected.z*blueChannel.z;\n\n        // add up alpha\n        if (calcAlpha == true) \{\n            chromaDst.w = chromaDst.w + chromaDstEffected.w;\n        \}\n        else \{\n            chromaDst.w = src(0,0,3);\n        \}\n\n        //Mix Values with Original\n        chromaDst.x = chromaDst.x * chromaMixClamped + src(0,0,0) * (1.0f-chromaMixClamped);\n        chromaDst.y = chromaDst.y * chromaMixClamped + src(0,0,1) * (1.0f-chromaMixClamped);\n        chromaDst.z = chromaDst.z * chromaMixClamped + src(0,0,2) * (1.0f-chromaMixClamped);\n        if (calcAlpha == true) \{\n            chromaDst.w = chromaDst.w * chromaMixClamped + src(0,0,3) * (1.0f-chromaMixClamped);\n        \}\n\n        //DEBUG\n        // chromaDst.x = 1.0f;\n\n\n        dst() = chromaDst;\n\n    \}\n    // Chromatic Aberration Kernel end\n\n\n    // simplified noise call for Chromatic Aberration\n    inline float getNoise(int2 pos, float amplitudeFromCenter) \{\n        float noiseVal;\n\n        noiseVal = pow( fbm_noise_3d( octaves, gain, lacunarity, ( ((float)pos.x) * scale.x ) + offset.x, ( ((float)pos.y) * scale.y ) + offset.y, ( zz * scale.z ) + offset.z ) * amplitude * amplitudeFromCenter, 1.0f / gammaClamped );\n\n        return noiseVal;\n    \}\n\n\n    // noise\n    // fbm_Noise_blink_kernel v1.0 by Johannes Saam - Nukepedia\n\n    // Permutation table.  The same list is repeated twice.\n    inline int perm( int index )\n    \{\n        int permData\[512] = \{\n            151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n            8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n            35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n            134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n            55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n            18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n            250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n            189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n            172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n            228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n            107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n            138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n            151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,\n            8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,\n            35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,\n            134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,\n            55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,\n            18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,\n            250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,\n            189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,\n            172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,\n            228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,\n            107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,\n            138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n        \};\n        return permData\[index];\n    \};\n\n    // The gradients are the midpoints of the vertices of a cube.\n    inline float3 grad3( int index )\n    \{\n        float grad3Data\[12*3] = \{ 1.0f,1.0f,0.0f,-1.0f,1.0f,0.0f,1.0f,-1.0f,0.0f,-1.0f,-1.0f,0.0f,1.0f,0.0f,1.0f,-1.0f,0.0f,1.0f,1.0f,0.0f,-1.0f,-1.0f,0.0f,-1.0f,0.0f,1.0f,1.0f,0.0f,-1.0f,1.0f,0.0f,1.0f,-1.0f,0.0f,-1.0f,-1.0f \};\n\n        return (float3)(grad3Data\[index*3], grad3Data\[(index*3) + 1], grad3Data\[(index*3) + 2]);\n    \};\n\n    inline float dotNoise( float3 g, float x, float y, float z )\n    \{\n        return g.x*x + g.y*y + g.z*z;\n    \};\n\n    inline int fastfloor( float x )\n    \{\n        if( x > 0.0f )\n        \{\n            return (int)(x);\n        \}\n        else\n        \{\n            return (int)(x - 1);\n        \}\n    \};\n\n    // 3D raw Simplex noise\n    inline float raw_noise_3d(\t\tfloat x, float y, float z ) \{\n        float n0, n1, n2, n3; // Noise contributions from the four corners\n\n        // Skew the input space to determine which simplex cell we're in\n        float F3 = 1.0f/3.0f;\n        float s = (x+y+z)*F3; // Very nice and simple skew factor for 3D\n        int i = fastfloor(x+s);\n        int j = fastfloor(y+s);\n        int k = fastfloor(z+s);\n\n        float G3 = 1.0f/6.0f; // Very nice and simple unskew factor, too\n        float t = (i+j+k)*G3;\n        float X0 = i-t; // Unskew the cell origin back to (x,y,z) space\n        float Y0 = j-t;\n        float Z0 = k-t;\n        float x0 = x-X0; // The x,y,z distances from the cell origin\n        float y0 = y-Y0;\n        float z0 = z-Z0;\n\n        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n        // Determine which simplex we are in.\n        int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n        int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n\n        if( x0 >= y0 )\n        \{\n            if( y0>=z0 )\n            \{\n                i1=1; j1=0; k1=0; i2=1; j2=1; k2=0;\n            \} // X Y Z order\n            else if( x0 >= z0 )\n            \{\n                i1=1; j1=0; k1=0; i2=1; j2=0; k2=1;\n            \} // X Z Y order\n            else\n            \{\n                i1=0; j1=0; k1=1; i2=1; j2=0; k2=1;\n            \} // Z X Y order\n        \}\n        else\n        \{   // x0<y0\n            if(y0<z0) \{\n                i1=0; j1=0; k1=1; i2=0; j2=1; k2=1;\n            \} // Z Y X order\n            else if(x0<z0) \{\n                i1=0; j1=1; k1=0; i2=0; j2=1; k2=1;\n            \} // Y Z X order\n            else \{\n                i1=0; j1=1; k1=0; i2=1; j2=1; k2=0;\n            \} // Y X Z order\n        \}\n\n        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n        // c = 1/6.\n        float x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n        float y1 = y0 - j1 + G3;\n        float z1 = z0 - k1 + G3;\n        float x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords\n        float y2 = y0 - j2 + 2.0*G3;\n        float z2 = z0 - k2 + 2.0*G3;\n        float x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords\n        float y3 = y0 - 1.0 + 3.0*G3;\n        float z3 = z0 - 1.0 + 3.0*G3;\n\n        // Work out the hashed gradient indices of the four simplex corners\n        int ii = i & 255;\n        int jj = j & 255;\n        int kk = k & 255;\n        int gi0 = perm(ii+perm(jj+perm(kk))) % 12;\n        int gi1 = perm(ii+i1+perm(jj+j1+perm(kk+k1))) % 12;\n        int gi2 = perm(ii+i2+perm(jj+j2+perm(kk+k2))) % 12;\n        int gi3 = perm(ii+1+perm(jj+1+perm(kk+1))) % 12;\n\n        // Calculate the contribution from the four corners\n        float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;\n        if( t0 < 0 )\n        \{\n            n0 = 0.0;\n        \}\n        else\n        \{\n            t0 *= t0;\n            n0 = t0 * t0 * dotNoise(grad3(gi0), x0, y0, z0);\n        \}\n\n        float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;\n        if( t1<0 )\n        \{\n            n1 = 0.0;\n        \}\n        else\n        \{\n            t1 *= t1;\n            n1 = t1 * t1 * dotNoise(grad3(gi1), x1, y1, z1);\n        \}\n\n        float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;\n        if( t2 < 0 )\n        \{\n            n2 = 0.0;\n        \}\n        else\n        \{\n            t2 *= t2;\n            n2 = t2 * t2 * dotNoise(grad3(gi2), x2, y2, z2);\n        \}\n\n        float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;\n        if( t3 < 0 )\n        \{\n            n3 = 0.0;\n        \}\n        else \{\n            t3 *= t3;\n            n3 = t3 * t3 * dotNoise(grad3(gi3), x3, y3, z3);\n        \}\n\n        // Add contributions from each corner to get the final noise value.\n        // The result is scaled to stay just inside \[-1,1]\n        return 32.0*(n0 + n1 + n2 + n3);\n    \};\n\n    // 3D Multi-octave Simplex noise.\n    //\n    // For each octave, a higher frequency/lower amplitude function will be added to the original.\n    // The higher the persistence \[0-1], the more of each succeeding octave will be added.\n    inline float octave_noise_3d(\tfloat octaves, float persistence, float scale, float x, float y, float z ) \{\n        float total = 0;\n        float frequency = scale;\n        float amplitude = 1;\n\n        // We have to keep track of the largest possible amplitude,\n        // because each octave adds more, and we need a value in \[-1, 1].\n        float maxAmplitude = 0;\n        int i = 0;\n        for( i=0; i < octaves; i++ )\n        \{\n            total += raw_noise_3d( x * frequency, y * frequency, z * frequency ) * amplitude;\n\n            frequency *= 2.0f;\n            maxAmplitude += amplitude;\n            amplitude *= persistence;\n        \}\n\n        return total / maxAmplitude;\n    \};\n\n    inline float fbm_noise_3d(\tfloat octaves, float gain, float lacunarity, float x, float y, float z ) \{\n\n        float total = 0.0f;\n        float frequency = 1.0f;\n        float amplitude = gain;\n\n        int i = 0;\n        for ( i = 0; i < octaves; i++ )\n        \{\n            total += raw_noise_3d( x * frequency, y * frequency, z * frequency ) * amplitude;\n            frequency *= lacunarity;\n            amplitude *= gain;\n        \}\n\n        return total / 2.0f + 1.0f;\n    \};\n    // fbm_Noise_blink_kernel v1.0 by Johannes Saam ends here\n\n\};\n"
  rebuild ""
  "ChromaticAberrationKernel_Smear Chroma" {{smear_chroma}}
  "ChromaticAberrationKernel_True Chroma Blur" {{true_chroma}}
  ChromaticAberrationKernel_calcAlpha {{calc_alpha}}
  ChromaticAberrationKernel_Resolution {{width} {height}}
  ChromaticAberrationKernel_Center {{center} {center}}
  "ChromaticAberrationKernel_Chroma Mult" {{strength}}
  "ChromaticAberrationKernel_Chroma Red Mult" {{redscale} {redscale}}
  "ChromaticAberrationKernel_Chroma Green Mult" {{greenscale} {greenscale}}
  "ChromaticAberrationKernel_Chroma Blue Mult" {{bluescale} {bluescale}}
  "ChromaticAberrationKernel_Chroma Rotation" {{rotation}}
  "ChromaticAberrationKernel_Chroma Mix" {{chroma_mix}}
  ChromaticAberrationKernel_Gamma {{noise_gamma}}
  ChromaticAberrationKernel_amplitude {{noise_amplitude}}
  ChromaticAberrationKernel_Offset {{noise_offset} {noise_offset} {noise_offset}}
  ChromaticAberrationKernel_Scale {{noise_scale} {noise_scale} {noise_scale}}
  rebuild_finalise ""
  name BlinkScript3
  xpos -4
  ypos 370
 }
 Output {
  name Output1
  xpos -4
  ypos 470
 }
end_group
